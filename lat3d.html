<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Illumina 3D Lattice — Compact Fit</title>
<meta name="color-scheme" content="dark">
<meta name="theme-color" content="#0b0d11">
<style>
  :root{--bg:#0a0b10;--ink:#eef1ff}
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{
    margin:0;background:
    radial-gradient(1200px 900px at 70% -10%,rgba(183,167,255,.10),transparent 60%),
    radial-gradient(900px 700px at 10% 110%,rgba(255,154,199,.08),transparent 60%),#0a0b10;
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--ink);overflow:hidden
  }
  .hud{position:fixed;left:50%;top:12px;transform:translateX(-50%);letter-spacing:.16em;font-weight:800;font-size:11px;color:#cfd3ff;opacity:.95;pointer-events:none}
  canvas{display:block;width:100vw;height:100vh;outline:none}
</style>
</head>
<body>
<div class="hud">ILLUMINA · WEBGL · drag / pinch / wheel · compact</div>
<canvas id="gl"></canvas>
<script>
const canvas=document.getElementById('gl');
let gl;
function fit(){canvas.width=innerWidth;canvas.height=innerHeight}
fit();addEventListener('resize',fit);
gl=canvas.getContext('webgl',{alpha:false,antialias:true,depth:true,stencil:false,powerPreference:'high-performance'});

// ---------- shaders ----------
const vs=`
attribute vec3 aPos, aNormal;
uniform mat4 uMVP, uModel, uNormalMat;
varying vec3 vN, vPos;
void main(){
  vec4 wp = uModel*vec4(aPos,1.0);
  vPos = wp.xyz;
  vN = normalize((uNormalMat*vec4(aNormal,0.0)).xyz);
  gl_Position = uMVP*vec4(aPos,1.0);
}`;
const fs=`
precision mediump float;
varying vec3 vN, vPos;
uniform vec3 uColorA, uColorB, uEye;
uniform float uAlpha;
void main(){
  vec3 V = normalize(uEye - vPos);
  float ndv = max(dot(normalize(vN), V), 0.0);
  float rim = pow(1.0-ndv, 2.1);
  vec3 base = mix(uColorA,uColorB,0.55 + 0.45*clamp(vPos.y*0.12, -1.0, 1.0));
  vec3 col = base*(0.58 + 0.42*rim) + vec3(0.95)*pow(1.0-ndv,3.0)*0.35;
  gl_FragColor = vec4(col, uAlpha);
}`;
const vsl=`
attribute vec3 aPos;
uniform mat4 uMVP;
void main(){ gl_Position = uMVP*vec4(aPos,1.0); }`;
const fsl=`
precision mediump float;
uniform vec4 uColor;
void main(){ gl_FragColor = uColor; }`;

function prog(vsSrc,fsSrc){
  const p=gl.createProgram();
  const v=gl.createShader(gl.VERTEX_SHADER), f=gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(v,vsSrc); gl.compileShader(v);
  gl.shaderSource(f,fsSrc); gl.compileShader(f);
  gl.attachShader(p,v); gl.attachShader(p,f); gl.linkProgram(p);
  return p;
}
const pSphere=prog(vs,fs), pLine=prog(vsl,fsl);

// ---------- geometry ----------
function sphere(lat=22,lon=22){
  const pos=[], nor=[], idx=[];
  for(let y=0;y<=lat;y++){
    const v=y/lat, phi=v*Math.PI;
    for(let x=0;x<=lon;x++){
      const u=x/lon, th=u*Math.PI*2.0;
      const sx=Math.sin(phi)*Math.cos(th), sy=Math.cos(phi), sz=Math.sin(phi)*Math.sin(th);
      pos.push(sx,sy,sz); nor.push(sx,sy,sz);
    }
  }
  for(let y=0;y<lat;y++){
    for(let x=0;x<lon;x++){
      const i=y*(lon+1)+x;
      idx.push(i,i+lon+1,i+1, i+1,i+lon+1,i+lon+2);
    }
  }
  return {
    pos:new Float32Array(pos),
    nor:new Float32Array(nor),
    idx:new Uint16Array(idx)
  };
}
const sph=sphere(24,24);
function buf(type,data){const b=gl.createBuffer();gl.bindBuffer(type,b);gl.bufferData(type,data,gl.STATIC_DRAW);return b}
const bPos=buf(gl.ARRAY_BUFFER,sph.pos);
const bNor=buf(gl.ARRAY_BUFFER,sph.nor);
const bIdx=buf(gl.ELEMENT_ARRAY_BUFFER,sph.idx);

function m4mul(a,b){const o=new Float32Array(16);for(let i=0;i<4;i++)for(let j=0;j<4;j++)o[i*4+j]=a[i*4+0]*b[0*4+j]+a[i*4+1]*b[1*4+j]+a[i*4+2]*b[2*4+j]+a[i*4+3]*b[3*4+j];return o}
function m4id(){const m=new Float32Array(16);m[0]=m[5]=m[10]=m[15]=1;return m}
function m4t(x,y,z){const m=m4id();m[12]=x;m[13]=y;m[14]=z;return m}
function m4s(s){const m=m4id();m[0]=m[5]=m[10]=s;return m}
function m4rx(a){const c=Math.cos(a),s=Math.sin(a),m=m4id();m[5]=c;m[6]=s;m[9]=-s;m[10]=c;return m}
function m4ry(a){const c=Math.cos(a),s=Math.sin(a),m=m4id();m[0]=c;m[2]=s;m[8]=-s;m[10]=c;return m}
function m4pers(fov,asp,n,f){const t=1/Math.tan(fov/2),m=new Float32Array(16);m[0]=t/asp;m[5]=t;m[10]=(f+n)/(n-f);m[11]=-1;m[14]=(2*f*n)/(n-f);return m}
function m4look(eye,tgt,up){const zx=eye[0]-tgt[0],zy=eye[1]-tgt[1],zz=eye[2]-tgt[2];const zl=1/Math.hypot(zx,zy,zz);const z=[zx*zl,zy*zl,zz*zl];let x=[up[1]*z[2]-up[2]*z[1],up[2]*z[0]-up[0]*z[2],up[0]*z[1]-up[1]*z[0]];const xl=1/Math.hypot(x[0],x[1],x[2]);x=[x[0]*xl,x[1]*xl,x[2]*xl];const y=[z[1]*x[2]-z[2]*x[1],z[2]*x[0]-z[0]*x[2],z[0]*x[1]-z[1]*x[0]];const m=m4id();m[0]=x[0];m[4]=x[1];m[8]=x[2];m[1]=y[0];m[5]=y[1];m[9]=y[2];m[2]=z[0];m[6]=z[1];m[10]=z[2];m[12]=-(x[0]*eye[0]+x[1]*eye[1]+x[2]*eye[2]);m[13]=-(y[0]*eye[0]+y[1]*eye[1]+y[2]*eye[2]);m[14]=-(z[0]*eye[0]+z[1]*eye[1]+z[2]*eye[2]);return m}
function m4inv(a){const i=new Float32Array(16);i[0]=a[5]*a[10]*a[15]-a[5]*a[11]*a[14]-a[9]*a[6]*a[15]+a[9]*a[7]*a[14]+a[13]*a[6]*a[11]-a[13]*a[7]*a[10];i[4]=-a[4]*a[10]*a[15]+a[4]*a[11]*a[14]+a[8]*a[6]*a[15]-a[8]*a[7]*a[14]-a[12]*a[6]*a[11]+a[12]*a[7]*a[10];i[8]=a[4]*a[9]*a[15]-a[4]*a[11]*a[13]-a[8]*a[5]*a[15]+a[8]*a[7]*a[13]+a[12]*a[5]*a[11]-a[12]*a[7]*a[9];i[12]=-a[4]*a[9]*a[14]+a[4]*a[10]*a[13]+a[8]*a[1]*a[14]-a[8]*a[2]*a[13]-a[12]*a[1]*a[10]+a[12]*a[2]*a[9];i[1]=-a[1]*a[10]*a[15]+a[1]*a[11]*a[14]+a[9]*a[2]*a[15]-a[9]*a[3]*a[14]-a[13]*a[2]*a[11]+a[13]*a[3]*a[10];i[5]=a[0]*a[10]*a[15]-a[0]*a[11]*a[14]-a[8]*a[2]*a[15]+a[8]*a[3]*a[14]+a[12]*a[2]*a[11]-a[12]*a[3]*a[10];i[9]=-a[0]*a[9]*a[15]+a[0]*a[11]*a[13]+a[8]*a[1]*a[15]-a[8]*a[3]*a[13]-a[12]*a[1]*a[11]+a[12]*a[3]*a[9];i[13]=a[0]*a[9]*a[14]-a[0]*a[10]*a[13]-a[8]*a[1]*a[14]+a[8]*a[2]*a[13]+a[12]*a[1]*a[10]-a[12]*a[2]*a[9];i[2]=a[1]*a[6]*a[15]-a[1]*a[7]*a[14]-a[5]*a[2]*a[15]+a[5]*a[3]*a[14]+a[13]*a[2]*a[7]-a[13]*a[3]*a[6];i[6]=-a[0]*a[6]*a[15]+a[0]*a[7]*a[14]+a[4]*a[2]*a[15]-a[4]*a[3]*a[14]-a[12]*a[2]*a[7]+a[12]*a[3]*a[6];i[10]=a[0]*a[5]*a[15]-a[0]*a[7]*a[13]-a[4]*a[1]*a[15]+a[4]*a[3]*a[13]+a[12]*a[1]*a[7]-a[12]*a[3]*a[5];i[14]=-a[0]*a[5]*a[14]+a[0]*a[6]*a[13]+a[4]*a[1]*a[14]-a[4]*a[2]*a[13]-a[12]*a[1]*a[6]+a[12]*a[2]*a[5];i[3]=-a[1]*a[6]*a[11]+a[1]*a[7]*a[10]+a[5]*a[2]*a[11]-a[5]*a[3]*a[10]-a[9]*a[2]*a[7]+a[9]*a[3]*a[6];i[7]=a[0]*a[6]*a[11]-a[0]*a[7]*a[10]-a[4]*a[2]*a[11]+a[4]*a[3]*a[10]+a[8]*a[2]*a[7]-a[8]*a[3]*a[6];i[11]=-a[0]*a[5]*a[11]+a[0]*a[7]*a[9]+a[4]*a[1]*a[11]-a[4]*a[3]*a[9]-a[8]*a[1]*a[7]+a[8]*a[3]*a[5];i[15]=a[0]*a[5]*a[10]-a[0]*a[6]*a[9]-a[4]*a[1]*a[10]+a[4]*a[2]*a[9]+a[8]*a[1]*a[6]-a[8]*a[2]*a[5];let d=a[0]*i[0]+a[1]*i[4]+a[2]*i[8]+a[3]*i[12];d=1/d;for(let k=0;k<16;k++)i[k]*=d;return i}
function m4tr(m){const o=new Float32Array(16);for(let i=0;i<4;i++)for(let j=0;j<4;j++)o[i*4+j]=m[j*4+i];return o}

// ---------- compact layout ----------
function palette(a,b){return {a,b}}
const colors={
  illumina:palette([0.85,0.87,1.00],[0.53,0.63,1.00]),
  mirrorhoney:palette([0.72,0.66,1.00],[1.00,0.60,0.78]),
  honey:palette([1.00,0.83,0.54],[1.00,0.74,0.74]),
  clarity:palette([0.77,0.93,1.00],[0.63,0.83,1.00]),
  mirrorsea:palette([0.47,0.78,1.00],[0.16,0.44,0.75]),
  tunes:palette([0.60,0.63,0.68],[0.85,0.85,0.90]),
  froot:palette([1.00,0.70,0.61],[0.77,0.62,1.00])
};

// scale down based on shorter side for tight fit
function scaleBase(){
  const s=Math.min(innerWidth,innerHeight);
  // base radius smaller on phones
  return (s<700)? 1.45 : 1.75;
}
let R=scaleBase();

// smaller spheres
const NODES=[
  {name:'Illumina',pos:[0,0,0],r:0.30,col:colors.illumina,alpha:0.85},
  {name:'MirrorHoney',pos:[0,R,0],r:0.22,col:colors.mirrorhoney,alpha:0.8},
  {name:'Clarity',pos:[ R*0.82,0.10, R*0.52],r:0.20,col:colors.clarity,alpha:0.78},
  {name:'Honey',pos:[-R*0.82,0.08, R*0.50],r:0.20,col:colors.honey,alpha:0.78},
  {name:'MirrorSea',pos:[0.15,-R*0.72,-R*0.65],r:0.20,col:colors.mirrorsea,alpha:0.76},
  {name:'Tunes',pos:[-R*0.78,-0.15,-R*0.40],r:0.18,col:colors.tunes,alpha:0.72},
  {name:'Froot',pos:[ R*0.78,-0.12,-R*0.38],r:0.19,col:colors.froot,alpha:0.78}
];
const EDGES=[[0,1],[0,2],[0,3],[0,4],[0,5],[0,6]];

// ---------- buffers ----------
const lineData=[]; for(const [a,b] of EDGES){lineData.push(...NODES[a].pos,...NODES[b].pos)}
const bLines=buf(gl.ARRAY_BUFFER,new Float32Array(lineData));

// ---------- controls ----------
let ax=0.5, ay=0.7, dist=(innerWidth<700?5.8:6.6);
let dragging=false, px=0, py=0;
canvas.addEventListener('mousedown',e=>{dragging=true;px=e.clientX;py=e.clientY});
addEventListener('mousemove',e=>{if(!dragging)return; ay+=(e.clientX-px)/300; ax+=(e.clientY-py)/300; px=e.clientX; py=e.clientY});
addEventListener('mouseup',()=>dragging=false);
canvas.addEventListener('wheel',e=>{
  dist=Math.max(4.2,Math.min(9.5,dist+e.deltaY*0.002));
},{passive:true});
canvas.addEventListener('touchstart',e=>{if(e.touches.length==1){dragging=true;px=e.touches[0].clientX;py=e.touches[0].clientY}},{passive:true});
canvas.addEventListener('touchmove',e=>{if(!dragging)return;const t=e.touches[0];ay+=(t.clientX-px)/300;ax+=(t.clientY-py)/300;px=t.clientX;py=t.clientY},{passive:true});
canvas.addEventListener('touchend',()=>dragging=false);

// ---------- draw ----------
gl.enable(gl.DEPTH_TEST);
gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

function useSphere(){
  gl.useProgram(pSphere);
  const aPos=gl.getAttribLocation(pSphere,'aPos');
  const aNor=gl.getAttribLocation(pSphere,'aNormal');
  gl.bindBuffer(gl.ARRAY_BUFFER,bPos); gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0); gl.enableVertexAttribArray(aPos);
  gl.bindBuffer(gl.ARRAY_BUFFER,bNor); gl.vertexAttribPointer(aNor,3,gl.FLOAT,false,0,0); gl.enableVertexAttribArray(aNor);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,bIdx);
}
function useLine(){
  gl.useProgram(pLine);
  const aPos=gl.getAttribLocation(pLine,'aPos');
  gl.bindBuffer(gl.ARRAY_BUFFER,bLines); gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0); gl.enableVertexAttribArray(aPos);
}

function render(){
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(0.04,0.05,0.07,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  // gentle auto-rotate
  if(!dragging){ ay+=0.0025; ax+=0.0011 }

  const asp=canvas.width/canvas.height;
  const proj=m4pers(42*Math.PI/180,asp,0.1,50);
  const rot=m4mul(m4ry(ay),m4rx(ax));
  const eye=[Math.sin(ay)*dist*Math.cos(ax*0.35), 1.2+Math.sin(ax)*0.9, Math.cos(ay)*dist];
  const view=m4look(eye,[0,0,0],[0,1,0]);
  const viewProj=m4mul(proj,view);
  const normalMat=m4tr(m4inv(rot));

  // edges
  useLine();
  const uMVPL=gl.getUniformLocation(pLine,'uMVP');
  const uColor=gl.getUniformLocation(pLine,'uColor');
  gl.uniformMatrix4fv(uMVPL,false,m4mul(viewProj,rot));
  gl.uniform4f(uColor,1,1,1,0.18);
  gl.drawArrays(gl.LINES,0,lineData.length/3);

  // spheres (small, compact)
  useSphere();
  const uMVP=gl.getUniformLocation(pSphere,'uMVP');
  const uModel=gl.getUniformLocation(pSphere,'uModel');
  const uNormalMat=gl.getUniformLocation(pSphere,'uNormalMat');
  const uColorA=gl.getUniformLocation(pSphere,'uColorA');
  const uColorB=gl.getUniformLocation(pSphere,'uColorB');
  const uEye=gl.getUniformLocation(pSphere,'uEye');
  const uAlpha=gl.getUniformLocation(pSphere,'uAlpha');
  gl.uniform3f(uEye,eye[0],eye[1],eye[2]);

  for(const n of NODES){
    const model=m4mul(rot,m4mul(m4t(n.pos[0],n.pos[1],n.pos[2]),m4s(n.r)));
    gl.uniformMatrix4fv(uModel,false,model);
    gl.uniformMatrix4fv(uNormalMat,false,normalMat);
    gl.uniformMatrix4fv(uMVP,false,m4mul(viewProj,model));
    gl.uniform3f(uColorA,n.col.a[0],n.col.a[1],n.col.a[2]);
    gl.uniform3f(uColorB,n.col.b[0],n.col.b[1],n.col.b[2]);
    gl.uniform1f(uAlpha,n.alpha);
    gl.drawElements(gl.TRIANGLES,sph.idx.length,gl.UNSIGNED_SHORT,0);
  }

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
